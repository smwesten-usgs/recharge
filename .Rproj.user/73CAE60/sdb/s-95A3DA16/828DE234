{
    "collab_server" : "",
    "contents" : "#' Baseflow Separation\n#'\n#' Extract baseflow from a daily streamflow record using the method proposed by\n#'the Institute of Hydrology (1980a,b), and as implemented by Wahl and Wahl (1988).\n#'\n#'The original description of constructing turning points proposed dividing\n#'water years into 5-day increments and selecting the minimum flow for each period.\n#'Gustard and others (1992) describe using continuous 5-day increments rather than restarting\n#'on the water year.\n#'\n#' @param discharge the daily streamflow to be separated missing values are not permitted\n#'within the time specified by \\code{Start} and \\code{end}.\n#' @param date the date for each \\code{discharge} value, should be of class \"Date.\" Missing values\n#'are not permitted.\n#' @param by string describing how to construct turning points: \"water year\", \"calendar_year\", or\n#'   \"continuous\".\n#' @param f the factor for identifying turning points.\n#' @param N the time perod for period for calculating the turning points.\n#' @param STAID the station identifier for the data.\n#' @references Gustard, A., Bullock, A., and Dixon, J.M., 1992,\n#'Low flow estimation in the United Kingdom: Institue of Hydrology\n#'Report No. 108, 88 p. and appendixes.\n#'\n#'Institute of Hydrology, 1980a, Low flow studies:\n#'Wallingford, Oxon, United Kingdom, Report No. I, 41 p.\n#'\n#'Institute of Hydrology, 1980b, Low flow studies: Wallingford, Oxon,\n#'United Kingdom, Report No. 3, p. 12- 19.\n#'\n#'Wahl, K.L., and Wahl, T.L., 1988, BFIâ€”A computer program for determining an index\n#' to base flow: US Bureau of Reclamation Water Resources Research Laboratory,\n#'  accessed August 25, 2004: U.S. Bureau of Reclamation.\n#'\n#' @return an object of class \"baseflow\" and inherits class \"data.frame\" of the selected data, a data\n#'frame of the baseflow information, and other information about the analysis.\n#' @keywords baseflow\n#' @examples\n#'\n#'\\dontrun{\n#'# Process by calendar year as that is the retrieval range\n#'ChopBFI <- with(ChoptankFlow, bfi(Flow, datetime, by=\"calendar year\",\n#'STAID=\"01491000\"))\n#'head(ChopBFI, 20)\n#'}\n#'@export\nbfi <- function(date, discharge, by=\"water year\", f=0.9, N=5L, STAID=\"Unknown\") {\n\n  STAID <- as.character(STAID[1L])\n  discharge <- pmax(discharge, 0.0001 ) # Convert 0 to a small number\n\n  if(any(is.na(discharge)))\n    stop(\"Missing discharge values.\")\n  if(any(diff(as.double(date)) != 1))\n    stop(\"Date data are not continuous.\")\n  by <- match.arg(by, c(\"water year\", \"calendar year\", \"continuous\"))\n  if(by == \"calendar year\") {\n    ## Cut pts\n    Cut <- c(seq(0, 360, by=N), 366)\n    ## Process data by years\n    year <- lubridate::year(date)\n    dayno <- yday # from lubridate\n  } else if(by == \"water year\") {\n    Cut <- c(seq(0, 360, by=N), 366)\n    year <- waterYear(date, numeric=TRUE)\n    dayno <- function(x) {\n      Jul <- as.integer(x)\n      lWY <- waterYear(x, numeric=TRUE) - 1L\n      baseWY <- as.integer(as.Date(ISOdate(lWY, 9, 30)))\n      return(Jul - baseWY)\n    }\n  } else { # for now continuous\n    Cut <- c(seq(0, length(discharge) + N, by=N))\n    year <- rep(1L, length(discharge))\n    dayno <- function(x) seq(1L, by=1L, length.out=length(x))\n  }\n  DF <-  data.frame(date=date, discharge=discharge)\n  ret <- by(DF, year, function(DF) {\n    Jul <- dayno(DF$Dates)\n    Grp <- cut(Jul, Cut, labels=FALSE)\n    retval <- tapply(DF$Q, Grp, function(x) {\n      Min <- min(x)\n      Wch <- which(Min == x)[1L]\n      return(c(Min, Wch))\n    }) # end of lapply\n    retval <- do.call('rbind', retval)\n    retval[,2L] <- retval[, 2L]+Cut[unique(Grp)]\n    return(retval)}\n    )\n  ## Note: if the first year is a partial year, then need to subtract\n  ##  the [starting day number] from the pointer (ret[,2]) for that first\n  ##  year. The correction is applied secondarily.\n  yeartbl <- cumsum(c(0, table(year))) # The number to add to each pointer\n  for(i in seq( length( ret ) ))\n    ret[[i]][, 2L] <- ret[[i]][, 2L] + yeartbl[i]\n  Jstrt <- dayno(date[1L])\n  if(Jstrt > 1L)\n    ret[[1L]][, 2L] <- ret[[1L]][, 2L] - Jstrt + 1L\n  ## The matrix ret are the minima and the index to the value\n  ret <- do.call('rbind', ret)\n  ## Now calculate the turning points\n  TP <- rep(FALSE, nrow(ret))\n  for(i in seq(2L, nrow(ret)-1L)) {\n    if(ret[i, 1L] == 0) {\n      TP[i] <- TRUE\n    } else if(ret[i - 1L, 1L] == 0) {\n      TP[i] <- f*ret[i, 1L] <= ret[i+1L, 1L]\n    } else if(ret[i + 1L, 1L] == 0) {\n      TP[i] <- f*ret[i, 1L] <= ret[i-1L, 1L]\n    } else {\n      TP[i] <- f*ret[i, 1L] <= min(ret[i-1L, 1L], ret[i+1L, 1L])\n    }\n  }\n  TPdat <- ret[TP,]\n  BaseQ <- rep(NA, length=length(Flow))\n  for(i in seq(1L, nrow(TPdat)-1L)) {\n    Rng <- seq(TPdat[i, 2L], TPdat[i+1L, 2L])\n    if(TPdat[i, 1L] == 0 || TPdat[i+1L, 1L] == 0) { # Use linear interpolation\n      BaseQ[Rng] <- pmin(Flow[Rng], seq(TPdat[i, 1L], TPdat[i+1L, 1L],\n                                          length.out=TPdat[i+1L, 2L] - TPdat[i, 2L]+1L))\n    } else\n      BaseQ[Rng] <- pmin(Flow[Rng], exp(seq(log(TPdat[i, 1L]), log(TPdat[i+1L, 1L]),\n                                            length.out=TPdat[i+1L, 2L] - TPdat[i, 2L]+1L)))\n  }\n  TurnPt <- rep(\" \", length(Flow))\n  TurnPt[TPdat[,2]] <- \"*\"\n  retval <- data.frame(Dates=Dates, BaseQ=BaseQ, Flow=Flow, TurnPt=TurnPt)\n  if(!is.null(STAID))\n    attr(retval, \"STAID\") <- STAID\n  attr(retval, \"type\") <- \"bfi\"\n  class(retval) <- c(\"baseflow\", \"data.frame\")\n  return(retval)\n}\n\n",
    "created" : 1503511049494.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1748679634",
    "id" : "828DE234",
    "lastKnownWriteTime" : 1503521162,
    "last_content_update" : 1503521162574,
    "path" : "/Volumes/smwesten/Source_Code/recharge/R/bfi.R",
    "project_path" : "R/bfi.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}