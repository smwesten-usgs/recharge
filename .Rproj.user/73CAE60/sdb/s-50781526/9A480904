{
    "collab_server" : "",
    "contents" : "#' Baseflow Separation\n#'\n#' Extract baseflow from a daily streamflow record using the method described by\n#'Rutledge (1998).\n#'\n#' @param Flow the daily streamflow to be separated missing values are not permitted\n#'within the time specified by \\code{Start} and \\code{end}.\n#' @param Dates the date for each \\code{x}, should be of class \"Date.\" Missing values\n#'are not permitted.\n#' @param Start the start date for the analysis, can be either a character string or\n#'class \"Date.\"\n#' @param End the end date for the analysis, can be either a character string or\n#'class \"Date.\"\n#' @param da the drainage area of the basin in square miles.\n#' @param STAID the station identifier for the data.\n#' @references Rutledge, A.T., 1998, Computer programs for describing the recession of\n#'ground-water discharge and for estimating mean ground-water recharge and discharge\n#'from streamflow records---Update: U.S. geological Survey Water-Resources Investigations\n#'Report 98-4148. 43 p.\n#'\n#' @return an object of class \"baseflow\" and inherits class \"data.frame\" of the selected data,\n#'a data frame of the baseflow information, and other information about the analysis.\n#' @note The estimates from this routine will occasionally differ slightly from the original\n#'FORTRAN code from Rutledge (1998). It is expected that those small differences are due to\n#'rounding differences affecting comparison between numbers that differ by very small amounts.\n#'There are also differences in the initial baseflow estimates between this version and the \n#'original version. Those differences are due to slightly different initialization routines.\n#'\n#'The estimate of baseflow from this routine is computed from a linear interpolation of the\n#'\\code{Part1} and \\code{Part2} estimates rather than the curvilinear interpolation that was \n#'proposed without detials in Rutledge (1998).\n#' @keywords baseflow\n#' @examples\n#'\n#'\\dontrun{\n#'library(smwrData)\n#'data(ChoptankFlow)\n#'# Process by calendar year as that is the retrieval range\n#'ChopPart <- with(ChoptankFlow, part(Flow, datetime, da=113,\n#'STAID=\"01491000\"))\n#'ChopPart\n#'}\n#'@export\npart <- function(Flow, Dates, Start=NULL, End=NULL, da,\n                 STAID=\"Unknown\") {\n  ## Start of code: initial processing\n  STAID <- as.character(STAID[1L])\n  if(is.null(Start))\n    Start <- Dates[1L]\n  else if(is.character(Start))\n    Start <- as.Date(Start)\n  if(is.null(End))\n    End <- Dates[length(Dates)]\n  else if(is.character(End))\n    End <- as.Date(End)\n  sel <- (Dates >= Start) & (Dates <= End)\n  Dates <- Dates[sel]\n  Flow <- pmax(Flow[sel], 1e-99) # Convert 0 to a small number\n  if(any(is.na(Flow)))\n    stop(\"Missing values between \", Start, \" and \", End)\n  if(any(diff(as.double(Dates)) != 1))\n    stop(\"Date data are not continuous between Start and End\")\n  Nact <- max(da^0.2, 1)\n  N <- as.integer(ceiling(Nact))\n  NF <- max(N-1L, 1L)\n  NC <- max(N, 2L)\n  NC1 <- NC + 1L\n  ## From the flow chart in Rutledge, with additions for 0 flows\n  ## The variable suffixes are F is the floor of Nact, C is the\n  ## ceiling of Nact, and C1 is the ceiling plus 1. These correspond\n  ## to the three values of N in Rutledge.\n  ##\n  # Step 1 set up data (Flow already done)\n  ## ALLGW is set to logical: TRUE (*) and FALSE (0)\n  ALLGWF <- ALLGWC <- ALLGWC1 <- rep(FALSE, length(Flow))\n  BaseQF <- BaseQC <- BaseQC1 <- rep(NA_real_, length(Flow))\n  # Step 2 Recored all GW flow where antecendent recession OK\n  DiffQ <- c(0, diff(Flow))\n  AnteF <- na2miss(filter(DiffQ <= 0, rep(1, NF), sides=1), 0)\n  AnteC <- na2miss(filter(DiffQ <= 0, rep(1, NC), sides=1), 0)\n  AnteC1 <- na2miss(filter(DiffQ <= 0, rep(1, NC1), sides=1), 0)\n  ALLGWF <- ifelse(AnteF == NF, TRUE, ALLGWF)\n  BaseQF <- ifelse(ALLGWF, Flow, BaseQF)\n  ALLGWC <- ifelse(AnteC == NC, TRUE, ALLGWC)\n  BaseQC <- ifelse(ALLGWC, Flow, BaseQC)\n  ALLGWC1 <- ifelse(AnteC1 == NC1, TRUE, ALLGWC1)\n  BaseQC1 <- ifelse(ALLGWC1, Flow, BaseQC1)\n  # Step 3 Revise all GW where necessary\n  CkQ <- (Flow > 1e-9) & (Flow/shiftData(Flow, k=-1, fill=1) > 1.258925)\n  ALLGWF <- ifelse(ALLGWF & CkQ, FALSE, ALLGWF)\n  ALLGWC <- ifelse(ALLGWC & CkQ, FALSE, ALLGWC)\n  ALLGWC1 <- ifelse(ALLGWC1 & CkQ, FALSE, ALLGWC1)\n  # Step 4 Interpolate Baseflows\n  Seq <- seq(length(Flow))\n  BaseQF <- exp(approx(Seq[ALLGWF], log(Flow[ALLGWF]), xout=Seq, rule=2)$y)\n  BaseQC <- exp(approx(Seq[ALLGWC], log(Flow[ALLGWC]), xout=Seq, rule=2)$y)\n  BaseQC1 <- exp(approx(Seq[ALLGWC1], log(Flow[ALLGWC1]), xout=Seq, rule=2)$y)\n  # Steps 5, 6, and 4 for each F, C, C1\n  while(any(CkQ <- (BaseQF > Flow + 0.000001))) { # Avoid rounding problems\n    CkQ <- CkQ & !ALLGWF # The trouble makers\n    Ck0 <- eventNum(!ALLGWF, reset=TRUE) # Each block of !ALLGW\n    CkE <- unique(Ck0[CkQ])\n    ## Find the largest ratio (log difference) in each block of !ALLGW\n    for(i in CkE) {\n      Sel <- which(Ck0 == i) # Select from this group\n      MaxR <- BaseQF[Sel]/Flow[Sel]\n      Pck <- which.max(MaxR)\n      ALLGWF[Sel[Pck]] <- TRUE\n      BaseQF[Sel[Pck]] <- Flow[Sel[Pck]]\n    }\n    ## Redo 4\n    BaseQF <- exp(approx(Seq[ALLGWF], log(Flow[ALLGWF]), xout=Seq, rule=2)$y)\n    BaseQF <- ifelse(BaseQF < 1e-6, 0, BaseQF) # Clean up\n  }\n  \n  while(any(CkQ <- (BaseQC > Flow + 0.000001))) { # Avoid rounding problems\n    CkQ <- CkQ & !ALLGWC # The trouble makers\n    Ck0 <- eventNum(!ALLGWC, reset=TRUE) # Each block of !ALLGW\n    CkE <- unique(Ck0[CkQ])\n    ## Find the largest ratio (log difference) in each block of !ALLGW\n    for(i in CkE) {\n      Sel <- which(Ck0 == i) # Select from this group\n      MaxR <- BaseQC[Sel]/Flow[Sel]\n      Pck <- which.max(MaxR)\n      ALLGWC[Sel[Pck]] <- TRUE\n      BaseQC[Sel[Pck]] <- Flow[Sel[Pck]]\n    }\n    ## Redo 4\n    BaseQC <- exp(approx(Seq[ALLGWC], log(Flow[ALLGWC]), xout=Seq, rule=2)$y)\n    BaseQC <- ifelse(BaseQC < 1e-6, 0, BaseQC)\n  }\n  \n  while(any(CkQ <- (BaseQC1 > Flow + 0.000001))) { # Avoid rounding problems\n    CkQ <- CkQ & !ALLGWC1 # The trouble makers\n    Ck0 <- eventNum(!ALLGWC1, reset=TRUE) # Each block of !ALLGW\n    CkE <- unique(Ck0[CkQ])\n    ## Find the largest ratio (log difference) in each block of !ALLGW\n    for(i in CkE) {\n      Sel <- which(Ck0 == i) # Select from this group\n      MaxR <- BaseQC1[Sel]/Flow[Sel]\n      Pck <- which.max(MaxR)\n      ALLGWC1[Sel[Pck]] <- TRUE\n      BaseQC1[Sel[Pck]] <- Flow[Sel[Pck]]\n    }\n    ## Redo 4\n    BaseQC1 <- exp(approx(Seq[ALLGWC1], log(Flow[ALLGWC1]), xout=Seq, rule=2)$y)\n    BaseQC1 <- ifelse(BaseQC1 < 1e-6, 0, BaseQC1)\n  }\n  ## Wrap up\n  ## Compute the linear interpolation of baseflow\n  Ffact <- NC - Nact # Must be between 0 and 1\n  BaseQ <- BaseQF*Ffact + BaseQC*(1-Ffact)\n  retval <- data.frame(Dates=Dates, BaseQ=round(BaseQ, 3L), \n                       Flow=round(Flow, 3L), Part1=BaseQF, Part2=BaseQC, \n                       Part3=BaseQC1)\n  if(!is.null(STAID))\n    attr(retval, \"STAID\") <- STAID\n  attr(retval, \"type\") <- \"part\"\n  class(retval) <- c(\"baseflow\", \"data.frame\")\n  return(retval)\n}\n  \n",
    "created" : 1503521281888.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3875257588",
    "id" : "9A480904",
    "lastKnownWriteTime" : 1503506463,
    "last_content_update" : 1503506463,
    "path" : "/Volumes/smwesten/Source_Code/recharge/R/part.R",
    "project_path" : "R/part.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}